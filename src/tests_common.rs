//! Helper function for writing tests

use std::iter;

/// Generate an iterator of bytestring keys, with increasing length up to a
/// maximum value.
///
/// This iterator will produce `max_len` number of keys. Each key has the form
/// `[0*, u8::MAX]`, meaning zero or more 0 values, followed by a single
/// `u8::MAX` value. The final `u8::MAX` value is added to ensure that no key is
/// a prefix of another key generated by this function.
///
/// # Examples
///
/// ```
/// # use blart::tests_common::generate_keys_skewed;
/// let mut keys = generate_keys_skewed(10).collect::<Vec<_>>();
/// assert_eq!(keys.len(), 10);
/// assert_eq!(keys[0].as_ref(), &[255]);
/// assert_eq!(keys[keys.len() - 1].as_ref(), &[0, 0, 0, 0, 0, 0, 0, 0, 0, 255]);
///
/// for k in keys {
///     println!("{:?}", k);
/// }
/// ```
///
/// The above example will print
/// ```text
/// [255]
/// [0, 255]
/// [0, 0, 255]
/// [0, 0, 0, 255]
/// [0, 0, 0, 0, 255]
/// [0, 0, 0, 0, 0, 255]
/// [0, 0, 0, 0, 0, 0, 255]
/// [0, 0, 0, 0, 0, 0, 0, 255]
/// [0, 0, 0, 0, 0, 0, 0, 0, 255]
/// [0, 0, 0, 0, 0, 0, 0, 0, 0, 255]
/// ```
///
/// # Panics
///  - Panics if `max_len` is 0.
pub fn generate_keys_skewed(max_len: usize) -> impl Iterator<Item = Box<[u8]>> {
    assert!(max_len > 0);

    iter::successors(Some(vec![u8::MAX; 1].into_boxed_slice()), move |prev| {
        if prev.len() < max_len {
            let mut key = vec![u8::MIN; prev.len()];
            key.push(u8::MAX);
            Some(key.into_boxed_slice())
        } else {
            None
        }
    })
}

/// Generate an iterator of bytestring keys, all with the same length.
///
/// This iterator will produce `max_len * value_stops + 1` keys in total. The
/// keys will start from all 0 values, then each key digit will increment by
/// `u8::MAX / value_stops`. Each new key will only increment a single key
/// digit.
///
/// # Examples
///
/// ```
/// # use blart::tests_common::generate_key_fixed_length;
/// let mut keys = generate_key_fixed_length(3, 5).collect::<Vec<_>>();
/// assert_eq!(keys.len(), 16);
/// assert_eq!(keys[0].as_ref(), &[0, 0, 0]);
/// assert_eq!(keys[keys.len() - 1].as_ref(), &[255, 255, 255]);
///
/// for k in keys {
///     println!("{:?}", k);
/// }
/// ```
///
/// The above example will print
/// ```text
/// [0, 0, 0]
/// [51, 0, 0]
/// [51, 51, 0]
/// [51, 51, 51]
/// [102, 51, 51]
/// [102, 102, 51]
/// [102, 102, 102]
/// [153, 102, 102]
/// [153, 153, 102]
/// [153, 153, 153]
/// [204, 153, 153]
/// [204, 204, 153]
/// [204, 204, 204]
/// [255, 204, 204]
/// [255, 255, 204]
/// [255, 255, 255]
/// ```
///
/// # Panics
///
///  - Panics if `max_len` is 0.
///  - Panics if `value_stops` is 0.
pub fn generate_key_fixed_length(
    max_len: usize,
    value_stops: u8,
) -> impl Iterator<Item = Box<[u8]>> {
    assert!(max_len > 0);
    assert!(value_stops > 0);

    iter::successors(
        Some(vec![u8::MIN; max_len].into_boxed_slice()),
        move |prev| {
            if prev.iter().all(|digit| *digit == u8::MAX) {
                None
            } else {
                let first_byte = prev[0];
                let mut next = prev.clone();

                match prev
                    .iter()
                    .enumerate()
                    .find(|(_, byte)| **byte != first_byte)
                {
                    Some((different_idx, differed_byte)) => {
                        next[different_idx] = differed_byte.saturating_add(u8::MAX / value_stops);
                    },
                    None => next[0] = first_byte.saturating_add(u8::MAX / value_stops),
                }

                Some(next)
            }
        },
    )
}
